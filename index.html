<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>ES2015: An Introduction</title>
    <link rel="stylesheet" type="text/css" href="build/build.css">
  </head>
  <body>
    <article>
      <section>
        <h1>ES2015</h1>
        <h2>An Introduction</h2>
      </section>
      <section>
        <h1>Variable Declaration - Block Scope</h1>
      </section>
      <section>
        <h1>"let"</h1>
        <ul class="l-p-t10 bullet">
          <li>Let restricts the scope of the variable to block scope</li>
          <li>There is no variable hoisting as there is with using var</li>
          <li>Can be reassigned</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">function addNumbers(arrayOfNumbers) {
    let total = 0;
    
    arraryOfNumbers.forEach(function(number) {
        let sum = total + number;
        total = sum;
    });
}</code></pre>
      </section>
      <section>
        <h1>"const"</h1>
        <ul class="l-p-t10 bullet">
          <li>Creates a read-only reference to a variable with block scope</li>
          <li>Must specify a value at the time that the variable is declared</li>
          <li>Objects defined with const can be manipulated, just not reassigned</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">const obj = {};
obj.name = "Brandon"; // This works

const obj = { name: 'Brandon' };
obj = {}; // This does not work, reference is changing
</code></pre>
      </section>
      <section>
        <h1>Template Strings</h1>
        <ul class="l-p-t10 bullet">
          <li>Syntactic sugar for constructing strings</li>
          <li>Similar to string interpolation in other languages</li>
          <li>To use: wrap text in back-ticks, use ${variableName} to inject dynamic values into strings</li>
          <li>Multiline strings are also possible</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">var name = "Brandon";
console.log(`My name is ${name}`);

`This is now
okay to do provided backticks are used`
</code></pre>
      </section>
      <section>
        <h1>Enhanced object literals</h1>
        <ul class="l-p-t10 bullet">
          <li>If the key and value have the same name, the value can be omitted</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">let name = "Brandon";

// The below 2 are the same
let obj = { name };
let obj1 = { name: name };</code></pre>
        <ul class="l-p-t10 bullet">
          <li>Object literal properties can now be computed values instead of only static</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">const propertyName = 'name';
const obj = { [propertyName]: 'Brandon'};
</code></pre>
      </section>
      <section>
        <h1>Arrow Functions </h1>
        <h2>aka "Fat Arrow"</h2>
        <ul class="l-p-t10 bullet">
          <li>More concise way of declaring functions</li>
          <li>Arrow functions retain lexical scope of 'this' inside the function</li>
          <li>No more doing this:<span class="l-m-l10"><code class="language-javascript small">var thisView = this;</code></span></li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">let arrayOfNumbers = [1, 2, 3, 4, 5];

arrayOfNumbers.forEach((number) => {
    // 'this' is the same inside here!
    console.log(number);
});</code></pre>
      </section>
      <section>
        <h1>Destructuring</h1>
      </section>
      <section>
        <h1>Array Destructuring</h1>
        <ul class="l-p-10 bullet">
          <li>Helpful for returning multiple values from a function</li>
          <li>Easily assign multiple variables at a time</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">let [firstValue] = [1];
console.log(firstValue); // 1
let [firstValue, secondValue] = [1, 2];
console.log(firstValue, secondValue); // 1, 2
let [, secondValue] = [1, 2];
console.log(secondValue); // 2
</code></pre>
      </section>
      <section>
        <h1>String Destructuring</h1>
        <ul class="l-p-10 bullet">
          <li>Strings can also be destructured very similar to arrays</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">let [a, b, c] = 'abc';
console.log(a, b, c) // a b c</code></pre>
      </section>
      <section>
        <h1>Object Destructuring</h1>
        <ul class="l-p-10 bullet">
          <li>Objects values can be destructured as well</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">const { x } = { x: 1 }; // x = 1
</code></pre>
      </section>
      <section>
        <h1>Spread / Rest Operators</h1>
      </section>
      <section>
        <h1>Spread Operator</h1>
        <ul class="l-p-10 bullet">
          <li>Previously, in order to use an an array as an argument to a function, apply was needed</li>
          <li>Essentially, you are taking an array and "spreading" them out to multiple arguments.</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">function myFunction(x, y, x) {}
var args = [0, 1, 2];

myFunction.apply(null, args); // Old way
myFunction(...args); // With ES2015, spread operator can be used when invoking a function</code></pre>
        <ul class="l-p-10 bullet">
          <li>Constructing new arrays from older arrays also gets a lot simpler.</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">var parts = ['shoulders', 'knees'];
var lyrics = ['head', ...parts, 'and', 'toes'];
</code></pre>
      </section>
      <section>
        <h1>Rest Operator</h1>
        <ul class="l-p-10 bullet">
          <li>The rest operator is used when defining functions.</li>
          <li>Essentially, you are collapsing all remaining arguments into an array</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">function sum(first, ...others) {
    for(let i = 0; i < others.length; i++) {
        first += others[i];
    }
    
    return first;
}

// sum(1, 2, 3, 4) === 10
</code></pre>
      </section>
      <section>
        <h1>Default parameters</h1>
        <ul class="l-p-10 bullet">
          <li>Functions can also now have default parameter values</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">function add(x, y=5) {
    return x + y;
}

// y would get the value of 5 if the function was invoked as follows:
add(2); // === 7</code></pre>
      </section>
      <section>
        <h1>"Classes"</h1>
      </section>
      <section>
        <h1>Question / Comments</h1>
      </section>
      <section>
        <h1>es6katas.org</h1>
        <h1>babeljs.io</h1>
      </section>
    </article>
    <script src="build/build.js"></script>
  </body>
</html>