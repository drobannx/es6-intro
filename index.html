<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>ES2015: An Introduction</title>
    <link rel="stylesheet" type="text/css" href="build/build.css">
  </head>
  <body>
    <article>
      <section>
        <h1>ES2015</h1>
        <h2>An Introduction</h2>
      </section>
      <section>
        <h1>Variable Declarations </h1>
        <h2>Block Scope</h2>
      </section>
      <section>
        <h1>"let"</h1>
        <ul class="l-p-t10 bullet">
          <li>let restricts the scope of the variable to block scope</li>
          <li>Gets hoisted to the top of the block, but referencing the variable before declaration throws a ReferenceError</li>
          <li>Can be reassigned</li>
        </ul>
      </section>
      <section>
        <h1>"let"</h1>
        <pre class="small bullet"><code class="language-javascript small">function varTest() {
    var x = 31;
    if(true) {
        var x = 71
        console.log(x); // 71
    }
    
    console.log(x); // 71
}
function letTest() {
    let x = 31;
    
    if(true) {
        let x = 71;
        console.log(x); // 71
    }
    
    console.log(x); // 31
}</code></pre>
      </section>
      <section>
        <h1>"const"</h1>
        <ul class="l-p-t10 bullet">
          <li>Creates a read-only reference to a variable with block scope</li>
          <li>Must specify a value at the time that the variable is declared</li>
          <li>Objects defined with const can be manipulated, just not reassigned</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">const obj = {};
obj.name = "Brandon"; // This works

const obj = { name: 'Brandon' };
obj = {}; // This does not work, reference is changing
</code></pre>
      </section>
      <section>
        <h1>Template Strings</h1>
        <ul class="l-p-t10 bullet">
          <li>Syntactic sugar for constructing strings</li>
          <li>Similar to string interpolation in other languages</li>
          <li>To use: wrap text in backticks, use ${variableName} to inject dynamic values into strings</li>
          <li>Multiline strings are also possible</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">var name = "Brandon";
console.log(`My name is ${name}`);

`This is now
okay to do provided backticks are used`
</code></pre>
      </section>
      <section>
        <h1>Enhanced object literals</h1>
        <ul class="l-p-t10 bullet">
          <li>If the key and value have the same name, the value can be omitted</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">let name = "Brandon";

// The below 2 are the same
let obj = { name };
let obj1 = { name: name };
</code></pre>
      </section>
      <section>
        <h1>Enhanced object literals</h1>
        <ul class="l-p-t10 bullet">
          <li>Object literal properties can now be computed values instead of only static values</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">const propertyName = 'name';

// Old way
let obj = {};
obj[propertyName] = 'Brandon'

// New way
let obj = { [propertyName]: 'Brandon'};
</code></pre>
      </section>
      <section>
        <h1>Arrow Functions </h1>
        <h2>aka "Fat Arrow"</h2>
        <ul class="l-p-t10 bullet">
          <li>More concise way of declaring functions</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">(param1) => { console.log("I'm a function") };
param1 => { console.log("I'm a function") };

param1 => param1 * 5; // If curlys are omitted, the expression is returned;
param1 => { return param1 * 5; }
</code></pre>
      </section>
      <section>
        <h1>Arrow Functions</h1>
        <ul class="l-p-t10 bullet">
          <li>Arrow functions retain lexical scope of 'this' inside the function</li>
          <li>No more doing this:<span class="l-m-l10"><code class="language-javascript small">
                var thisView = this;
                </code></span></li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">function Person() {
    var self = this;
    self.age = 0;
    
    setInterval(function() {
        self.age++;
    }, 1000);
}
function Person() {
    this.age = 0;
    
    setInterval(() => {
        this.age++;
    }, 1000);
}</code></pre>
      </section>
      <section>
        <h1>Destructuring</h1>
      </section>
      <section>
        <h1>Array Destructuring</h1>
        <ul class="l-p-10 bullet">
          <li>Helpful for returning multiple values from a function</li>
          <li>Easily assign multiple variables at a time</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">let [firstValue] = [1];
console.log(firstValue); // 1
let [firstValue, secondValue] = [1, 2];
console.log(firstValue, secondValue); // 1, 2
let [, secondValue] = [1, 2];
console.log(secondValue); // 2
</code></pre>
      </section>
      <section>
        <h1>String Destructuring</h1>
        <ul class="l-p-10 bullet">
          <li>Strings can also be destructured very similar to arrays</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">let [a, b, c] = 'abc';
console.log(a, b, c) // a b c</code></pre>
      </section>
      <section>
        <h1>Object Destructuring</h1>
        <ul class="l-p-10 bullet">
          <li>Objects values can be destructured as well</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">const { x } = { x: 1 }; // x = 1
</code></pre>
      </section>
      <section>
        <h1>Spread / Rest Operators</h1>
      </section>
      <section>
        <h1>Spread Operator</h1>
        <ul class="l-p-10 bullet">
          <li>Previously, in order to use an array as an argument to a function, apply was needed</li>
          <li>Essentially, you are taking an array and "spreading" them out to multiple arguments.</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">function myFunction(x, y, x) {}
var args = [0, 1, 2];

myFunction.apply(null, args); // Old way
myFunction(...args); // With ES2015, spread operator can be used when invoking a function</code></pre>
        <ul class="l-p-10 bullet">
          <li>Constructing new arrays from older arrays also gets a lot simpler.</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">var parts = ['shoulders', 'knees'];
var lyrics = ['head', ...parts, 'and', 'toes'];
</code></pre>
      </section>
      <section>
        <h1>Rest Operator</h1>
        <ul class="l-p-10 bullet">
          <li>The rest operator is used when defining functions.</li>
          <li>Essentially, you are collapsing all remaining arguments into an array</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">function sum(first, ...others) {
    for(let i = 0; i < others.length; i++) {
        first += others[i];
    }
    
    return first;
}

// sum(1, 2, 3, 4) === 10
</code></pre>
      </section>
      <section>
        <h1>Default parameters</h1>
        <ul class="l-p-10 ticbullet">
          <li>Functions can also now have default parameter values</li>
        </ul>
        <pre class="small bullet"><code class="language-javascript small">function add(x, y) {
    y = y || 5;
    
    return x + y;
}

function add(x, y=5) {
    return x + y;
}

// y would get the value of 5 if the function was invoked as follows:
add(2); // === 7</code></pre>
      </section>
      <section>
        <h1>"Classes"</h1>
        <ul class="l-p-10 bullet">
          <li>Class syntax is syntatic sugar over the existing prototype based inheritance</li>
          <li>This is NOT introducting an OO model to JavaScript</li>
          <li>'constructor' is a reserved keyword function that gets called when an object is created</li>
          <li>Supports static methods which can be called without instantiating the class</li>
          <li>Functions defined in a class block do not need to be comma separated like an object literal</li>
        </ul>
      </section>
      <section>
        <h1>"Classes"</h1>
        <pre class="small bullet"><code class="language-javascript small">class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    
    static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
    }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);

console.log(Point.distance(p1, p2));</code></pre>
      </section>
      <section>
        <h1>Question / Comments</h1>
      </section>
      <section>
        <h1>es6katas.org</h1>
        <h1>babeljs.io</h1>
      </section>
    </article>
    <script src="build/build.js"></script>
  </body>
</html>